/*
 * Copyright 2020 MovingBlocks
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Dependencies needed for what our Gradle scripts themselves use. It cannot be included via an external Gradle file :-(
buildscript {
    repositories {
        // External libs - jcenter is Bintray and is supposed to be a superset of Maven Central, but do both just in case
        jcenter()
        mavenCentral()
        gradlePluginPortal()
    }

    dependencies {
        // Needed for caching reflected data during builds
        classpath 'org.reflections:reflections:0.9.10'
        classpath 'dom4j:dom4j:1.6.1'
    }
}

plugins {
    // Needed for extending the "clean" task to also delete custom stuff defined here like natives
    id "base"

    // IDEs
    // The root project should not be an eclipse project. It keeps eclipse (4.2) from finding the sub-projects.
    // id "eclipse" apply false
    id "idea"

    // Analytics
    id "project-report"
    id "checkstyle"
    id "pmd"
    id "com.github.spotbugs" version "4.2.0"
    id "jacoco"
    id "org.sonarqube" version "2.8"
}


// Test for right version of Java in use for running this script
assert org.gradle.api.JavaVersion.current().isJava8Compatible()

import org.gradle.internal.logging.text.StyledTextOutputFactory
import static org.gradle.internal.logging.text.StyledTextOutput.Style

subprojects {
    // Why use plugins {} block if we just list plugins again here?
    // The idea is that the plugins block "resolves" them, makes sure they have their dependencies, etc.
    // Then if they need to be applied to other things, the "apply plugin: x" syntax will use the
    // previously resolved value.

    apply plugin: "jacoco"
    apply plugin: "idea"
    apply plugin: "eclipse"

    apply plugin: "project-report"
    apply plugin: "checkstyle"
    apply plugin: "pmd"
    apply plugin: "com.github.spotbugs"
    apply plugin: "jacoco"
    apply plugin: "org.sonarqube"
}

// Check for Java 8
if(JavaVersion.current() != JavaVersion.VERSION_1_8){
    def out = services.get(StyledTextOutputFactory).create("an-ouput")
    out.withStyle(Style.FailureHeader).println("WARNING: You're compiling with a JDK newer than Java 8, this may not be fully supported for Terasology, consider adjusting your JAVA_HOME accordingly")
}

// Declare "extra properties" (variables) for the project (and subs) - a Gradle thing that makes them special.
ext {
    dirNatives = 'natives'
    dirConfigMetrics = 'config/metrics'
    templatesDir = 'templates'

    // Lib dir for use in manifest entries etc (like in :engine). A separate "libsDir" exists, auto-created by Gradle
    subDirLibs = 'libs'

    LwjglVersion = '2.9.3'
}

// Declare remote repositories we're interested in - library files will be fetched from here
repositories {
    // MovingBlocks Artifactory instance for libs not readily available elsewhere plus our own libs
    maven {
        name "Terasology Artifactory"
        url "http://artifactory.terasology.org/artifactory/virtual-repo-live"
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Natives - Handles pulling in and extracting native libraries for LWJGL                                            //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Define configurations for natives and config
configurations {
    natives
    codeMetrics
}

dependencies {
    // For the "natives" configuration make it depend on the native files from LWJGL
    natives group: 'org.lwjgl.lwjgl', name: 'lwjgl', version: LwjglVersion

    // Config for our code analytics lives in a centralized repo: https://github.com/MovingBlocks/TeraConfig
    codeMetrics group: 'org.terasology.config', name: 'codemetrics', version: '1.3.2', ext: 'zip'

    // Natives for JNLua (Kallisti, KComputers)
    natives group: 'org.terasology.jnlua', name: 'jnlua_natives', version: '0.1.0-SNAPSHOT', ext: 'zip'
}

task extractWindowsNatives(type: Copy) {
    description = "Extracts the Windows natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-window') ? zipTree(it) : [] }
    }
    into("$dirNatives/windows")
    exclude('META-INF/**')
}

task extractMacOSXNatives(type: Copy) {
    description = "Extracts the OSX natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-osx') ? zipTree(it) : [] }
    }
    into("$dirNatives/macosx")
    exclude('META-INF/**')
}

task extractLinuxNatives(type: Copy) {
    description = "Extracts the Linux natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-linux') ? zipTree(it) : [] }
    }
    into("$dirNatives/linux")
    exclude('META-INF/**')
}

task extractJNLuaNatives(type: Copy) {
    description = "Extracts the JNLua natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('jnlua') ? zipTree(it) : [] }
    }
    into("$dirNatives")
}

task extractNatives {
    description = "Extracts all the native lwjgl libraries from the downloaded zip"
    dependsOn extractWindowsNatives
    dependsOn extractLinuxNatives
    dependsOn extractMacOSXNatives
    dependsOn extractJNLuaNatives
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper tasks                                                                                                      //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task extractConfig(type: Copy) {
    description = "Extracts our configuration files from the zip we fetched as a dependency"
    from {
        configurations.codeMetrics.collect {
            zipTree(it)
        }
    }
    into "$rootDir/$dirConfigMetrics"
}


// This is a TEMPORARY tweak to make "changing" dependencies always ('0') check for newer snapshots available
// TODO: Remove this when versioning and promotion works fully, then we shouldn't care about snapshots normally anyway
configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

// Include deletion of extracted natives in the global clean task. Without the doLast it runs on *every* execution ...
clean.doLast {
    new File(dirNatives).deleteDir()
    new File(dirConfigMetrics).deleteDir()
    println "Cleaned root - don't forget to re-extract stuff! 'gradlew extractNatives extractConfig' will do so"
}

task protobufCompileWindows(type: Exec) {
    description = "Run 'Protobuf Compiler' (Windows)"
    commandLine 'protobuf\\compiler\\protoc.exe', '--proto_path=engine\\src\\main\\protobuf', '--java_out', 'engine\\src\\main\\java', 'engine\\src\\main\\protobuf\\*'
}

task protobufCompileLinux(type: Exec) {
    description = "Run 'Protobuf Compiler' (Linux)"
    commandLine 'protobuf/compiler/protoc', '--proto_path=engine/src/main/protobuf', '--java_out', 'engine/src/main/java', "engine/src/main/protobuf/EntityData.proto", "engine/src/main/protobuf/NetMessage.proto"
}


// Magic for replace remote dependency on local project (source)
allprojects {
    configurations.all {
        resolutionStrategy {
            preferProjectModules()
        }
    }
}


class DebugMyStuff implements DependencyResolutionListener {

    Logger logger
    Project rootProj

    DebugMyStuff(rootProj) {
        this.rootProj = rootProj
        logger = Logging.getLogger(this.class)
    }

    @Override
    void beforeResolve(ResolvableDependencies resolvableDependencies) {

    }

    @Override
    void afterResolve(ResolvableDependencies resolvableDependencies) {
        def resolutions = resolvableDependencies.resolutionResult
        def cfgPath = resolvableDependencies.path
        def cfgName = cfgPath.substring(cfgPath.lastIndexOf(":") + 1)
        def projPath = cfgPath.substring(0, cfgPath.lastIndexOf(":"))

        logger.info("🌹 {}", resolvableDependencies.dependencies)
//        logger.info("🌹 {}", resolvableDependencies.dependencyConstraints)
        logger.info("🌹 {}", resolvableDependencies.attributes)

        def first=true

        resolutions.allDependencies.findAll { onlyEngine(it) }.forEach {
            if (first) {
                configDisplay(projPath, cfgName)
                first = false
            }
            resultDisplay(it)
        }
    }

    boolean resultFilter(ResolvedDependencyResult result) {
        def requested = result.requested
        switch (requested) {
            case LibraryComponentSelector:
                return true
            case ModuleComponentSelector:
                return requested.group.startsWith("org.terasology")
            case ProjectComponentSelector:
                return true
            default:
                logger.warn("🎴 ? {} {}", requested.displayName, requested)
                return true
        }
    }

    @SuppressWarnings("GrMethodMayBeStatic")
    boolean onlyEngine(UnresolvedDependencyResult result) {
        return true;
    }

    boolean onlyEngine(ResolvedComponentResult result) {
        switch (result.id) {
            case ProjectComponentIdentifier:
                return result.id.projectPath.equals(":engine")
            case ModuleComponentIdentifier:
                return result.id.group.startsWith("org.terasology") && result.id.module.equals("engine")
            default:
                logger.warn("❓ {}", result)
                return true
        }
    }

    boolean onlyEngine(ResolvedDependencyResult result) {
        def requested = result.requested
        switch (requested) {
            case LibraryComponentSelector:
                return false
            case ModuleComponentSelector:
                return requested.group.startsWith("org.terasology") && requested.module.equals("engine")
            case ProjectComponentSelector:
                return requested.projectPath.startsWith(":engine")
            default:
                logger.warn("🎴 ? {} {}", requested.displayName, requested)
                return true
        }
    }

    void configDisplay(String projPath, String cfgName) {
        def theProject = rootProj.findProject(projPath)
        def theConfig = theProject.configurations.getByName(cfgName)
        def strats = theConfig.resolutionStrategy

        logger.info("📓 {} 👮{} 📕{}{}", strats.conflictResolution, strats.forcedModules, strats.componentSelection.rules,
                b(strats.dependencySubstitution.hasRules()))

        strats.capabilitiesResolution.all {
            logger.info("📓 D {}", it)
        }
    }

    void resultDisplay(UnresolvedDependencyResult result) {
        def requested = result.requested

        def selectedStr = '?'

        switch (requested) {
            case LibraryComponentSelector:
                logger.info("🎴 L ▣{} {} {} ➙ 💥{}", b(result.constraint), requested.libraryName, requested.projectPath, selectedStr)
                break
            case ModuleComponentSelector:
                logger.info("🎴 M ▣{} {} {} ➙ 💥{}", b(result.constraint), requested.moduleIdentifier, requested.versionConstraint, selectedStr)
                break
            case ProjectComponentSelector:
                logger.info("🎴 P ▣{} {} {} ➙ 💥{}", b(result.constraint), requested.displayName, requested.projectPath, selectedStr)
                break
            default:
                logger.warn("🎴 ? ▣{} {} {} ➙ 💥{}", b(result.constraint), requested.displayName, requested, selectedStr)
        }
    }

    void resultDisplay(ResolvedDependencyResult result) {
        def requested = result.requested
        def selectedId = result.selected.id
        def selectedStr

        switch (selectedId) {
            case ProjectComponentIdentifier:
                selectedStr = "🌼 "
                break
            case ModuleComponentIdentifier:
                selectedStr = "🧶 "
                break
            default:
                selectedStr = "❓ "
        }

        selectedStr += "${result.selected} ${result.selected.variants}"

        switch (requested) {
            case LibraryComponentSelector:
                logger.info("🎴 L ▣{} {} {} ➙ {}", b(result.constraint), requested.libraryName, requested.projectPath, selectedStr)
                break
            case ModuleComponentSelector:
                logger.info("🎴 M ▣{} {} {} ➙ {}", b(result.constraint), requested.moduleIdentifier, requested.versionConstraint, selectedStr)
                break
            case ProjectComponentSelector:
                logger.info("🎴 P ▣{} {} {} ➙ {}", b(result.constraint), requested.displayName, requested.projectPath, selectedStr)
                break
            default:
                logger.warn("🎴 ? ▣{} {} {} ➙ {}", b(result.constraint), requested.displayName, requested, selectedStr)
        }

        def reason = result.selected.selectionReason

        logger.info(" ╲   ▣{} ⚔{} 👮{} 📕{} {}", b(reason.constrained), b(reason.conflictResolution),
                b(reason.forced), b(reason.selectedByRule), result.from)

        for (desc in reason.descriptions.findAll { !(it.cause in [ComponentSelectionCause.ROOT]) }) {
            logger.info("                   ┕ {}", desc)
        }
    }

    static String b(boolean value) {
        return value ? "✅" : "⎵"
    }
}


gradle.addListener(new DebugMyStuff(rootProject))


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// General IDE customization                                                                                         //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task copyInMissingTemplates {
    description = "Copies in placeholders from the /templates dir to project root if not present yet"
    File gradlePropsFile = new File(rootDir, 'gradle.properties')
    File OverrideCfgFile = new File(rootDir, 'override.cfg')
    if (!gradlePropsFile.exists()) {
        new File(rootDir, 'gradle.properties') << new File(templatesDir, 'gradle.properties').text
    }
    if (!OverrideCfgFile.exists()) {
        new File(rootDir, 'override.cfg') << new File(templatesDir, 'override.cfg').text
    }
}

// Make sure the IDE prep includes extraction of natives
ideaModule.dependsOn extractNatives
ideaModule.dependsOn copyInMissingTemplates

// For IntelliJ add a bunch of excluded directories
idea {

    // Exclude Eclipse dirs
    // TODO: Update this as Eclipse bin dirs now generate in several deeper spots rather than at top-level
    module.excludeDirs += file('bin')
    module.excludeDirs += file('.settings')
    // TODO: Add a single file exclude for facades/PC/Terasology.launch ?

    // Exclude special dirs
    module.excludeDirs += file('natives')
    module.excludeDirs += file('protobuf')

    // Exclude output dirs
    module.excludeDirs += file('configs')
    module.excludeDirs += file('logs')
    module.excludeDirs += file('saves')
    module.excludeDirs += file('screenshots')
    module.excludeDirs += file('terasology-server')
    module.excludeDirs += file('terasology-2ndclient')

    module.downloadSources = true
}

cleanIdea.doLast {
    new File('Terasology.iws').delete()
}
