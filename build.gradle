/*
 * This is a Gradle build file:
 * - Gradle Homepage: http://gradle.org/
 * - Gradle Documentation: http://gradle.org/documentation
 * - View tasks for this project: $ gradlew tasks
 */

apply plugin: 'java'
apply plugin: 'project-report'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'checkstyle'

/*
 * Update Gradle Wrapper:
 * 1. Uncomment 'wrapper' task
 * 2. Change 'gradleVersion'
 * 3. Run 'gradlew wrapper'
 * 4. Comment 'wrapper' task
 */
// task wrapper(type: Wrapper) {
//     gradleVersion = '1.6'
// }

import groovy.json.JsonSlurper
import org.apache.tools.ant.filters.FixCrLfFilter;
import java.text.SimpleDateFormat;

def dateTimeFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX")
dateTimeFormat.timeZone = TimeZone.getTimeZone("UTC")

def LWJGL_VERSION = '2.9.0'
def JINPUT_VERSION = '2.0.5'

// Declare "extra properties" (variables) for the project - a Gradle thing that makes them special.
ext {
    // Project paths
    dirApplet = 'applet'
    dirNatives = 'natives'
    dirSaves = 'saves'
    subDirLibs = 'libs'
    subDirModules = 'mods'
    destDirApplet = 'distributions/applet'
    destDirApplication = 'distributions/application'
    destDirMainOutput = 'mainOutput'
    destDirModules = "distributions/$subDirModules"
    mainClassName = 'org.terasology.engine.Terasology'
	mainClassNameEditor = 'org.terasology.editor.TeraEd'
    jarFileName = 'Terasology.jar'
    templatesDir = file('templates')
    
    // Read environment variables, including variables passed by jenkins continuous integration server
    env = System.getenv() 
    
    // Settings for automatic version file
    startDateTimeString = dateTimeFormat.format(new Date())
    versionInfoFileDir = new File(sourceSets.main.output.resourcesDir, 'org/terasology/version')
    versionInfoFile = new File(versionInfoFileDir, 'versionInfo.properties')
    versionFileName = 'VERSION'
    versionBase = rootProject.file("templates/version.txt").text.trim()
    displayVersion = versionBase
}

// Declare remote repositories we're interested in - library files will be fetched from here
repositories {
    mavenCentral()
    maven {
        url "http://www.movingblocks.net:8081/artifactory/repo"
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Natives
//
// Handling of pulling in and extracting native libraries for lwjgl
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Define a custom configuration for Natives
configurations {
    natives
}

dependencies {
    natives group: 'org.lwjgl.lwjgl', name: 'lwjgl', version: LWJGL_VERSION
}

task extractWindowsNatives(type:Sync) {
    description = "Extracts the Windows natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-window') ? zipTree(it) : [] }
    }
    into ("$dirNatives/windows")
    exclude ('META-INF/**')
}

task extractMacOSXNatives(type:Sync) {
    description = "Extracts the OSX natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-osx') ? zipTree(it) : [] }
    }
    into ("$dirNatives/macosx")
    exclude ('META-INF/**')
}

task extractLinuxNatives(type:Sync) {
    description = "Extracts the Linux natives from the downloaded zip"
    from {
        configurations.natives.collect { it.getName().contains('-natives-linux') ? zipTree(it) : [] }
    }
    into ("$dirNatives/linux")
    exclude ('META-INF/**')
}

task extractNatives {
    description = "Extracts all the native lwjgl libraries from the downloaded zip"
    dependsOn extractWindowsNatives
    dependsOn extractLinuxNatives
    dependsOn extractMacOSXNatives
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Java
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
sourceCompatibility = 1.7

// Add additional "source set" beyond the default (src/main/ + src/test/), in this case src/dev/ (utility)
sourceSets {
    dev
}

// Customizations for the main compilation configuration
configurations {
    // Exclude a couple of LWJGL modules that aren't needed during compilation
    compile {
        exclude module: 'lwjgl-platform'
        exclude module: 'jinput-platform'
    }
    // Setup compilation for the dev source set
    devCompile.extendsFrom compile
}

// Primary dependenices definition
dependencies {
    compile group: 'org.codehaus.groovy', name: 'groovy', version: '1.8.7'
    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.2'
    compile group: 'com.google.guava', name: 'guava', version: '13.0.1'
    compile group: 'com.google.code.gson', name: 'gson', version: '2.2.4'
    compile group: 'com.google.protobuf', name: 'protobuf-java', version: '2.5.0'
    compile group: 'net.sf.trove4j', name: 'trove4j', version: '3.0.3'
    compile group: 'com.projectdarkstar.ext.jorbis', name: 'jorbis', version: '0.0.17'
    compile group: 'org.lwjgl.lwjgl', name: 'lwjgl', version: LWJGL_VERSION
    compile group: 'org.lwjgl.lwjgl', name: 'lwjgl_util', version: LWJGL_VERSION
    compile group: 'io.netty', name: 'netty', version: '3.6.5.Final'
    compile group: 'org.reflections', name: 'reflections', version: '0.9.8'
    compile group: 'java3d', name: 'vecmath', version: '1.3.1'
    compile group: 'net.java.dev.jna', name: 'jna', version: '3.5.2'
    compile group: 'net.java.dev.jna', name: 'platform', version: '3.5.2'
    compile group: 'org.newdawn.slick', name: 'slick', version: '237'
	compile group: 'org.terasology.bullet', name: 'tera-bullet', version: '1.0.0'
    
    // Also grab any libraries in the libs folder (not preferred)
    compile fileTree(dir: 'libs', include: '*.jar')
    
    // Needed as "compile" for logback.groovy in IntelliJ - otherwise it could be left as a runtime only dependency
    compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.0.13'
    
    // These dependencies are only needed for running tests
    testCompile group: 'junit', name: 'junit', version: '4.10'
    testCompile group: 'org.mockito', name: 'mockito-all', version: '1.9.0'
    testCompile group: 'org.jboss.shrinkwrap', name: 'shrinkwrap-depchain-java7', version: '1.1.3' 
    
    // The dev source set also needs these dependencines
    devCompile sourceSets.main.output
}

// Instructions for packaging a jar file of the main project
jar {
    archiveName = jarFileName
    manifest {
        def manifestClasspath = "$subDirLibs/"+configurations.runtime.collect { it.getName() }.join(" $subDirLibs/")
        attributes("Main-Class": mainClassName, "Class-Path" : manifestClasspath, "Implementation-Title": project.name, "Implementation-Version": env.BUILD_NUMBER + ", " + env.GIT_BRANCH + ", " + env.BUILD_ID + ", " + displayVersion)
    }
}

task sourceJar(type: Jar) {
    description = "Create a JAR with all sources (main: java, resources)"
    manifest.attributes("Implementation-Title": project.name)
    classifier = 'sources'
    from sourceSets.main.output
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    description = "Create a JAR with the JavaDoc for the java sources"
    manifest.attributes("Implementation-Title": project.name)
    classifier = 'javadoc'
    from javadoc.destinationDir
}

// Configuration for running unit tess
test {
    dependsOn extractNatives 

    // ignoreFailures: Specifies whether the build should break when the verifications performed by this task fail.
    ignoreFailures = true
    // showStandardStreams: makes the standard streams (err and out) visible at console when running tests
    testLogging.showStandardStreams = true
    // Arguments to include while running tests
    jvmArgs '-Xms512m', '-Xmx1024m', '-XX:MaxPermSize=128m'
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Modules
//
// Configuration around the creation and inclusion of modules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

subprojects {
    // Ignore the actual "mods" directory as it itself is not a module
    if (name != 'mods') {
        // Each module gets set up as Java and prepped for being turned into an Eclipse or IntelliJ project
        apply plugin: 'java'
        apply plugin: 'eclipse'
        apply plugin: 'idea'
        
        // Change the output dir of each module to classes, as this is where Terasology will look when loading modules
        sourceSets {
            main {
                java {
                    output.classesDir 'classes'
                }
            }
        }
        
        // Generate the module directory structure if missing
        task createSkeleton() {
            mkdir('assets')
            mkdir('assets/animations')
            mkdir('assets/blocks')
            mkdir('assets/blockTiles')
            mkdir('assets/fonts')
            mkdir('assets/materials')
            mkdir('assets/mesh')
            mkdir('assets/music')
            mkdir('assets/prefabs')
            mkdir('assets/shaders')
            mkdir('assets/shapes')
            mkdir('assets/skeletalMesh')
            mkdir('assets/sounds')
            mkdir('assets/textures')
            mkdir('src/main/java')
            mkdir('src/test/java')
        }
        // This task syncs everything in the assets dir into the output dir, used when jarring the module
        task syncAssets(type: Sync) {
            from 'assets'
            into 'classes/assets'
        }
        
        // This task creates a barebones module.txt if it is missing, from a template
        task createModuleManifest(type: Copy) {
            from templatesDir
            into projectDir
            include 'module.txt'
            expand(id: project.name)
        }
        
        def moduleDepends = [];
        def moduleFile = file('module.txt')
        // If moduleFile is missing, create it
        if (!moduleFile.exists()) {
            compileJava.dependsOn createModuleManifest
            createSkeleton.dependsOn createModuleManifest
			version = "1.0.0"
            
        // Otherwise, retrieve dependencies information from it
        } else {
            def slurper = new JsonSlurper()
            def moduleConfig = slurper.parseText( file('module.txt').text)
			for (dependency in moduleConfig.dependencies) { 
				if (dependency.id != 'engine') {
					moduleDepends += dependency.id
				}
			}
			version = moduleConfig.version
        }
        
        // Jarring needs to copy module.txt and all the assets into the output
        jar.doFirst {
            copy {
                from 'module.txt'
                into 'classes'
            }
        }
        jar.dependsOn syncAssets
        
        // Setup for IntelliJ projects
        idea {
            module {
                // Output into classes and testClasses rather than the default
                inheritOutputDirs = false
                outputDir = file('classes')
                testOutputDir = file('testClasses')
                iml {
                    generateTo = file('.idea')
                }
            }
        }
        // Setup for Eclipse projects
        eclipse {
            classpath {
                // Output into classes rather than the default
                defaultOutputDir = file('classes')
            }
        }
        // Same repository configuration as root project
        repositories {
            mavenCentral()
            maven {
                url "http://www.movingblocks.net:8081/artifactory/repo"
            }
        }
        // Set dependencies. Note that the dependency information from module.txt is used
        dependencies {
            compile project(':')
            testCompile group: 'junit', name: 'junit', version: '4.10'
            for (dependency in moduleDepends) {
                compile project(':mods:' + dependency)
            }
        }
    }
}

task moduleClasses {
    description = "Compile all modules"
    subprojects.each { project -> 
        if (project.name != 'mods') {
            moduleClasses.dependsOn project.tasks['classes']
        }
    }    
}

task moduleAssemble {
    description = "Assembles all modules"
    subprojects.each { project -> 
        if (project.name != 'mods') {
            moduleAssemble.dependsOn project.tasks['assemble']
        }
    }    
}
    
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checkstyle
//
// This is used to check the style of the source for compliance with our code style guidelines
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
checkstyle.ignoreFailures = true
checkstyle.configProperties.samedir = checkstyle.configFile.parentFile
/* Optional check plugins
apply plugin: 'codenarc'
apply plugin: 'findbugs'
apply plugin: 'pmd'

// ignoreFailures: Whether or not this task will ignore failures and continue running the build.
codenarc.ignoreFailures = true
findbugs.ignoreFailures = true
pmd.ignoreFailures = true
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Miscellaneous
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
task assembleMainOutput(type:Sync) {
    description = "Helper task for when the game is being run from the command line"
    from sourceSets.main.output
    into "$buildDir/$destDirMainOutput"
}

task run(type:JavaExec) {
    description = "Run 'Terasology' to play the game"

    dependsOn extractNatives
    dependsOn assembleMainOutput
    dependsOn moduleClasses
    main = mainClassName
    classpath "$buildDir/$destDirMainOutput"
    classpath configurations.runtime
}

task runTeraEd(type:JavaExec) {
    description = "Run 'TeraEd' to customize shader settings while the game is running"

    dependsOn extractNatives
    dependsOn assembleMainOutput
    dependsOn moduleClasses
    main = mainClassNameEditor
    classpath "$buildDir/$destDirMainOutput"
    classpath configurations.runtime
}

task deleteSaves(type: Delete) {
    description = "Delete all saved games"
    delete file(dirSaves).listFiles().findAll { it.directory }
}

task deleteSaveFiles(type: Delete) {
    description = "Delete all files in '$dirSaves'"
    delete file(dirSaves).listFiles().findAll { !it.directory }
}

task zipSavesFolder(type: Zip) {
    description = "Creates a Saves ZIP file from '$dirSaves'"
    appendix = "SavedGames"
    classifier = startDateTimeString
    into (dirSaves) {
        from dirSaves
    }
}

task runProtobufWindows(type:Exec) {
    description = "Run 'Protobuf Compiler' (Windows)"
    commandLine 'protobuf\\compiler\\protoc.exe', '--proto_path=src\\main\\protobuf', '--java_out', 'src\\main\\java', 'src\\main\\protobuf\\*'
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Version file
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task createVersionInfoFile {
    dependsOn processResources
    inputs.property('dateTime', startDateTimeString)
    onlyIf { env.BUILD_URL != null }
    doLast {
        versionInfoFileDir.mkdirs()
        ant.propertyfile (file: versionInfoFile) {
            ant.entry(key:'buildNumber',value:env.BUILD_NUMBER)
            ant.entry(key:'buildId',value:env.BUILD_ID)
            ant.entry(key:'buildTag',value:env.BUILD_TAG)
            ant.entry(key:'buildUrl',value:env.BUILD_URL)
            ant.entry(key:'jobName',value:env.JOB_NAME)
            ant.entry(key:'gitBranch',value:env.GIT_BRANCH)
            ant.entry(key:'gitCommit',value:env.GIT_COMMIT)
            ant.entry(key:'dateTime',value:startDateTimeString)
            ant.entry(key:'displayVersion',value:displayVersion)
        }
    }
}

jar.dependsOn createVersionInfoFile

task createVersionFile(type: Copy) {
    inputs.property('dateTime', startDateTimeString)
    onlyIf { env.BUILD_URL != null }
    from 'src/template'
    into "$buildDir"
    include versionFileName
    expand(buildNumber: env.BUILD_NUMBER, buildUrl: env.BUILD_URL, gitBranch: env.GIT_BRANCH, dateTime: startDateTimeString, displayVersion: displayVersion)
    filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Distributions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
task distModules {
    description = "Prepares the modules for distribution"
    dependsOn moduleAssemble
    subprojects.each { project -> 
        if (project.name != 'mods') {
            project.task('dist', type: Copy) {
                from (project.libsDir)
                into "$buildDir/$destDirModules"
            }
            distModules.dependsOn project.tasks['dist']
        }
    }
}

task distApplication(type:Sync) {
    description = "Creates an Application folder"
    dependsOn extractNatives
    dependsOn distModules
    into("$buildDir/$destDirApplication")
    from ('Heightmap.txt') {}
    from ('README.markdown') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
        rename('README.markdown', 'README')
    }
    from ('LICENSE') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
    }
    from ('NOTICE') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
    }
    from jar
    from('launchScripts') {
        exclude('Launcher.xml')
    }
    into(subDirLibs) {
        from configurations.runtime
    }
    into(dirNatives) {
        from dirNatives
    }
    into(subDirModules) {
        from "$buildDir/$destDirModules"
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Applet
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

configurations {
    applet
}

dependencies {
    applet group: 'org.lwjgl.lwjgl', name: 'lwjgl_util_applet', version: LWJGL_VERSION
}

task syncIntoApplet(type:Sync) {
    into("$buildDir/$destDirApplet")
    from ('README.markdown') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
        rename('README.markdown', 'README')
    }
    from ('LICENSE') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
    }
    from ('NOTICE') {
        filter(FixCrLfFilter, eol:FixCrLfFilter.CrLf.newInstance("crlf"))
    }
    from jar
    from configurations.applet
    into(subDirLibs) {
        from configurations.runtime
        from configurations.natives
    }
    into(subDirModules) {
        from "$buildDir/$destDirModules"
    }
}

task createIndexHtml(type:Copy) {
    mustRunAfter syncIntoApplet
    def jars = []
    configurations.runtime.each {
        jars += 'lib/' + it.getName()
    }
    def modules = []
    subprojects.each { project -> 
        if (project.name != 'mods') {
            modules += project.name + '.jar'
        }
    }
    from(dirApplet)
    into("$buildDir/$destDirApplet")
    include 'index.html'
    expand(lwjglVersion: LWJGL_VERSION, jinputVersion : JINPUT_VERSION, jars : jars.join(", "), modules : modules.join(", "))
}

task distApplet {
    description = "Creates an Applet folder"
    dependsOn distModules
    dependsOn syncIntoApplet
    dependsOn createIndexHtml    
}

// At the end of the applet distribution sign the jar files so they can get expanded rights in a browser
distApplet.doLast {
    file("$buildDir/$destDirApplet").listFiles().each {
        if (it.getName().endsWith(".jar"))
            ant.signjar(jar: it, keystore: "$dirApplet/tera.keystore", alias: 'Terasology', storepass: 'Terasology')
    }
    file("$buildDir/$destDirApplet/$subDirLibs").listFiles().each {
        if (it.getName().endsWith(".jar"))
            ant.signjar(jar: it, keystore: "$dirApplet/tera.keystore", alias: 'Terasology', storepass: 'Terasology')
    }
    file("$buildDir/$destDirApplet/$subDirMods").listFiles().each {
        if (it.getName().endsWith(".jar"))
            ant.signjar(jar: it, keystore: "$dirApplet/tera.keystore", alias: 'Terasology', storepass: 'Terasology')
    }
}

task distModulesZip(type:Zip) {
    description = "Creates a modules ZIP file from '$buildDir/$destDirModules'"
    dependsOn distModules
    appendix 'Mods'
    from "$buildDir/$destDirModules"
}

task distApplicationZip(type:Zip) {
    description = "Creates an Application ZIP file from '$buildDir/$destDirApplication'"
    dependsOn distApplication
    dependsOn createVersionInfoFile
    dependsOn createVersionFile
    //appendix 'Application'
    from "$buildDir/$destDirApplication"
    from "$buildDir/$versionFileName"
}

task distAppletZip(type:Zip) {
    description = "Creates an Applet ZIP file from '$buildDir/$destDirApplet'"
    dependsOn distApplet
    dependsOn createVersionInfoFile
    dependsOn createVersionFile
    appendix 'Applet'
    from "$buildDir/$destDirApplet"
    from "$buildDir/$versionFileName"
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IDE project setup
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ideaModule.dependsOn extractNatives
eclipseClasspath.dependsOn extractNatives

idea { 
    project {
        jdkName = '1.7'
        ipr {
            withXml {
                // Setup copyright statement injection
                def node = it.asNode()
                def copyrightManager = node.find {it.@name == 'CopyrightManager'}
                copyrightManager.@default = "TerasologyEngine"
                def copyright = copyrightManager.appendNode("copyright")
                copyright.appendNode("option", [name : "notice", value : 'Copyright 2013 MovingBlocks\n\nLicensed under the Apache License, Version 2.0 (the "License");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.']) 
                copyright.appendNode("option", [name : "keyword", value : "Copyright"])
                copyright.appendNode("option", [name : "allowReplaceKeywod", value : ""])
                copyright.appendNode("option", [name : "myName", value : "TerasologyEngine"])
                copyright.appendNode("option", [name : "myLocal", value : "true"])
                def langOptions = copyrightManager.appendNode("LanguageOptions", [name : "__TEMPLATE__"])
                langOptions.appendNode("option", [name : "addBlankAfter", value : "false"])
                
                // Setup knowledge of certain annotations being entry points (so don't mark annotated items as unused)
                def entryPointsManager = node.appendNode('component', [name : "EntryPointsManager"])
                def entryPoints = entryPointsManager.appendNode('entry_points', [version : '2.0'])
                def entryPointsList = entryPointsManager.appendNode('list', [size : '3'])
                entryPointsList.appendNode('item', [index : '0', class : 'java.lang.String', itemvalue : 'org.terasology.entitySystem.event.ReceiveEvent'])
                entryPointsList.appendNode('item', [index : '1', class : 'java.lang.String', itemvalue : 'org.terasology.entitySystem.systems.In'])
                entryPointsList.appendNode('item', [index : '2', class : 'java.lang.String', itemvalue : 'org.terasology.entitySystem.systems.RegisterSystem'])
                entryPointsList.appendNode('item', [index : '3', class : 'java.lang.String', itemvalue : 'org.terasology.logic.console.Command'])
            }
        }
    }
    // Add benchmarking "dev" directory
    module.sourceDirs += sourceSets.dev.allJava.srcDirs
    
    // Exclude these directories from the project view
    module.excludeDirs += file('bin')
    module.excludeDirs += file('gradle')
    module.excludeDirs += file('logs') 
    module.excludeDirs += file('natives')
    module.excludeDirs += file('protobuf')
    module.excludeDirs += file('saves')
    module.excludeDirs += file('screenshots')
}
    
