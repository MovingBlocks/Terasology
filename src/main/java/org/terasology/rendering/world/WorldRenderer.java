/*
 * Copyright 2012 Benjamin Glatzel <benjamin.glatzel@me.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.terasology.rendering.world;

import com.google.common.collect.Lists;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.GL11;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.terasology.asset.Assets;
import org.terasology.audio.AudioManager;
import org.terasology.componentSystem.RenderSystem;
import org.terasology.componentSystem.controllers.LocalPlayerSystem;
import org.terasology.config.Config;
import org.terasology.entitySystem.EntityManager;
import org.terasology.game.ComponentSystemManager;
import org.terasology.game.CoreRegistry;
import org.terasology.game.GameEngine;
import org.terasology.logic.LocalPlayer;
import org.terasology.logic.manager.DefaultRenderingProcess;
import org.terasology.logic.manager.PathManager;
import org.terasology.logic.manager.ShaderManager;
import org.terasology.logic.manager.WorldTimeEventManager;
import org.terasology.math.AABB;
import org.terasology.math.Rect2i;
import org.terasology.math.Region3i;
import org.terasology.math.Vector3i;
import org.terasology.monitoring.PerformanceMonitor;
import org.terasology.physics.BulletPhysics;
import org.terasology.rendering.AABBRenderer;
import org.terasology.rendering.cameras.Camera;
import org.terasology.rendering.cameras.OrthographicCamera;
import org.terasology.rendering.cameras.PerspectiveCamera;
import org.terasology.rendering.logic.MeshRenderer;
import org.terasology.rendering.primitives.ChunkMesh;
import org.terasology.rendering.primitives.ChunkTessellator;
import org.terasology.rendering.shader.ShaderProgram;
import org.terasology.world.BlockEntityRegistry;
import org.terasology.world.EntityAwareWorldProvider;
import org.terasology.world.WorldBiomeProvider;
import org.terasology.world.WorldInfo;
import org.terasology.world.WorldProvider;
import org.terasology.world.WorldProviderCoreImpl;
import org.terasology.world.WorldProviderWrapper;
import org.terasology.world.WorldTimeEvent;
import org.terasology.world.WorldView;
import org.terasology.world.block.Block;
import org.terasology.world.chunks.Chunk;
import org.terasology.world.chunks.ChunkState;
import org.terasology.world.chunks.provider.ChunkProvider;
import org.terasology.world.chunks.provider.LocalChunkProvider;
import org.terasology.world.chunks.store.ChunkStore;
import org.terasology.world.chunks.store.ChunkStoreProtobuf;
import org.terasology.world.generator.core.ChunkGeneratorManager;

import javax.imageio.ImageIO;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import java.awt.image.BufferedImage;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;

import static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;
import static org.lwjgl.opengl.GL11.GL_FILL;
import static org.lwjgl.opengl.GL11.GL_FRONT_AND_BACK;
import static org.lwjgl.opengl.GL11.GL_LINE;
import static org.lwjgl.opengl.GL11.glClear;
import static org.lwjgl.opengl.GL11.glCullFace;
import static org.lwjgl.opengl.GL11.glDisable;
import static org.lwjgl.opengl.GL11.glEnable;
import static org.lwjgl.opengl.GL11.glLoadIdentity;
import static org.lwjgl.opengl.GL11.glPolygonMode;
import static org.lwjgl.opengl.GL11.glPopMatrix;
import static org.lwjgl.opengl.GL11.glPushMatrix;

/**
 * The world of Terasology. At its most basic the world contains chunks (consisting of a fixed amount of blocks)
 * and the player.
 * <p/>
 * The world is randomly generated by using a bunch of Perlin noise generators initialized
 * with a favored seed value.
 *
 * @author Benjamin Glatzel <benjamin.glatzel@me.com>
 */
public final class WorldRenderer {
    public static final int MAX_ANIMATED_CHUNKS = 64;
    public static final int MAX_BILLBOARD_CHUNKS = 64;
    public static final int VERTICAL_SEGMENTS = CoreRegistry.get(Config.class).getSystem().getVerticalChunkMeshSegments();

    private static final Logger logger = LoggerFactory.getLogger(WorldRenderer.class);

    private Config config = CoreRegistry.get(Config.class);

    /* WORLD PROVIDER */
    private final WorldProvider worldProvider;
    private ChunkProvider chunkProvider;
    private ChunkStore chunkStore;

    /* PLAYER */
    private LocalPlayer player;

    /* CAMERAS */
    private Camera localPlayerCamera = new PerspectiveCamera();

    //private Camera lightCamera = new PerspectiveCamera();
    private Camera lightCamera = new OrthographicCamera(-500f, 500f, 500f, -500f);

    private Camera activeCamera = localPlayerCamera;

    /* CHUNKS */
    private ChunkTessellator chunkTessellator;
    private boolean pendingChunks = false;
    private final List<Chunk> chunksInProximity = Lists.newArrayList();
    private int chunkPosX, chunkPosZ;

    /* RENDERING */
    private final LinkedList<Chunk> renderQueueChunksOpaque = Lists.newLinkedList();
    private final LinkedList<Chunk> renderQueueChunksOpaqueShadow = Lists.newLinkedList();
    private final PriorityQueue<Chunk> renderQueueChunksSortedWater = new PriorityQueue<Chunk>(16 * 16, new ChunkProximityComparator());
    private final PriorityQueue<Chunk> renderQueueChunksSortedBillboards = new PriorityQueue<Chunk>(16 * 16, new ChunkProximityComparator());

    /* HORIZON */
    private final Skysphere skysphere;

    /* TICKING */
    private float tick = 0;

    /* UPDATING */
    private final ChunkUpdateManager chunkUpdateManager;

    /* EVENTS */
    private final WorldTimeEventManager worldTimeEventManager;

    /* PHYSICS */
    private final BulletPhysics bulletPhysics;

    /* BLOCK GRID */
    private final BlockGrid blockGrid;

    /* STATISTICS */
    private int statDirtyChunks = 0, statVisibleChunks = 0, statIgnoredPhases = 0;
    private int statChunkMeshEmpty, statChunkNotReady, statRenderedTriangles;

    /* ENUMS */
    private enum CHUNK_RENDER_MODE {
        DEFAULT,
        REFLECTED,
        SHADOW_MAP
    }

    private ComponentSystemManager _systemManager;

    private ChunkStore loadChunkStore(File file) throws IOException {
        FileInputStream fileIn = null;
        ObjectInputStream in = null;
        try {
            fileIn = new FileInputStream(file);
            in = new ObjectInputStream(fileIn);

            ChunkStore cache = (ChunkStore) in.readObject();
            if (cache instanceof ChunkStoreProtobuf)
                ((ChunkStoreProtobuf) cache).setup();
            else
                logger.warn("Chunk store might not have been initialized: {}", cache.getClass().getName());

            return cache;

        } catch (ClassNotFoundException e) {
            throw new IOException("Unable to load chunk cache", e);
        } finally {
            // JAVA7 : cleanup
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    logger.error("Failed to close input stream", e);
                }
            }
            if (fileIn != null) {
                try {
                    fileIn.close();
                } catch (IOException e) {
                    logger.error("Failed to close input stream", e);
                }
            }
        }
    }

    /**
     * Initializes a new (local) world for the single player mode.
     *
     * @param worldInfo Information describing the world
     */
    public WorldRenderer(WorldInfo worldInfo, ChunkGeneratorManager chunkGeneratorManager, EntityManager manager, LocalPlayerSystem localPlayerSystem) {
        // TODO: Cleaner method for this? Should not be using the world title
        File f = new File(PathManager.getInstance().getWorldSavePath(worldInfo.getTitle()), worldInfo.getTitle() + ".dat");
        if (f.exists()) {
            try {
                chunkStore = loadChunkStore(f);
            } catch (IOException e) {
                /* TODO: We really should expose this error via UI so player knows that there is an issue with their world
                   (don't have the game continue or we risk overwriting their game)
                 */
                e.printStackTrace();
            }
        }
        if (chunkStore == null) {
            chunkStore = new ChunkStoreProtobuf();
        }
        chunkProvider = new LocalChunkProvider(chunkStore, chunkGeneratorManager);
        EntityAwareWorldProvider entityWorldProvider = new EntityAwareWorldProvider(new WorldProviderCoreImpl(worldInfo, chunkProvider));
        CoreRegistry.put(BlockEntityRegistry.class, entityWorldProvider);
        CoreRegistry.get(ComponentSystemManager.class).register(entityWorldProvider, "engine:BlockEntityRegistry");
        worldProvider = new WorldProviderWrapper(entityWorldProvider);
        bulletPhysics = new BulletPhysics(worldProvider);
        chunkTessellator = new ChunkTessellator(worldProvider.getBiomeProvider());
        skysphere = new Skysphere(this);
        chunkUpdateManager = new ChunkUpdateManager(chunkTessellator, worldProvider);
        worldTimeEventManager = new WorldTimeEventManager(worldProvider);
        blockGrid = new BlockGrid();

        // TODO: won't need localPlayerSystem here once camera is in the ES proper
        localPlayerSystem.setPlayerCamera(localPlayerCamera);
        _systemManager = CoreRegistry.get(ComponentSystemManager.class);


        initTimeEvents();
    }

    /**
     * Updates the list of chunks around the player.
     *
     * @param force Forces the update
     * @return True if the list was changed
     */
    public boolean updateChunksInProximity(boolean force) {
        int newChunkPosX = calcCamChunkOffsetX();
        int newChunkPosZ = calcCamChunkOffsetZ();

        // TODO: This should actually be done based on events from the ChunkProvider on new chunk availability/old chunk removal
        int viewingDistance = config.getRendering().getActiveViewingDistance();

        if (chunkPosX != newChunkPosX || chunkPosZ != newChunkPosZ || force || pendingChunks) {
            // just add all visible chunks
            if (chunksInProximity.size() == 0 || force || pendingChunks) {
                chunksInProximity.clear();
                for (int x = -(viewingDistance / 2); x < viewingDistance / 2; x++) {
                    for (int z = -(viewingDistance / 2); z < viewingDistance / 2; z++) {
                        Chunk c = chunkProvider.getChunk(newChunkPosX + x, 0, newChunkPosZ + z);
                        if (c != null && c.getChunkState() == ChunkState.COMPLETE && worldProvider.getLocalView(c.getPos()) != null) {
                            chunksInProximity.add(c);
                        } else {
                            pendingChunks = true;
                        }
                    }
                }
            }
            // adjust proximity chunk list
            else {
                int vd2 = viewingDistance / 2;

                Rect2i oldView = new Rect2i(chunkPosX - vd2, chunkPosZ - vd2, viewingDistance, viewingDistance);
                Rect2i newView = new Rect2i(newChunkPosX - vd2, newChunkPosZ - vd2, viewingDistance, viewingDistance);

                // remove
                List<Rect2i> removeRects = Rect2i.subtractEqualsSized(oldView, newView);
                for (Rect2i r : removeRects) {
                    for (int x = r.minX(); x < r.maxX(); ++x) {
                        for (int y = r.minY(); y < r.maxY(); ++y) {
                            Chunk c = chunkProvider.getChunk(x, 0, y);
                            chunksInProximity.remove(c);
                        }
                    }
                }

                // add
                List<Rect2i> addRects = Rect2i.subtractEqualsSized(newView, oldView);
                for (Rect2i r : addRects) {
                    for (int x = r.minX(); x < r.maxX(); ++x) {
                        for (int y = r.minY(); y < r.maxY(); ++y) {
                            Chunk c = chunkProvider.getChunk(x, 0, y);
                            if (c != null && c.getChunkState() == ChunkState.COMPLETE && worldProvider.getLocalView(c.getPos()) != null) {
                                chunksInProximity.add(c);
                            } else {
                                pendingChunks = true;
                            }
                        }
                    }
                }
            }

            chunkPosX = newChunkPosX;
            chunkPosZ = newChunkPosZ;


            Collections.sort(chunksInProximity, new ChunkProximityComparator());

            return true;
        }

        return false;
    }

    private static class ChunkProximityComparator implements Comparator<Chunk> {

        @Override
        public int compare(Chunk o1, Chunk o2) {
            double distance = distanceToCamera(o1);
            double distance2 = distanceToCamera(o2);

            if (o1 == null) {
                return -1;
            } else if (o2 == null) {
                return 1;
            }

            if (distance == distance2)
                return 0;

            return distance2 > distance ? -1 : 1;
        }

        private float distanceToCamera(Chunk chunk) {
            Vector3f result = new Vector3f((chunk.getPos().x + 0.5f) * Chunk.SIZE_X, 0, (chunk.getPos().z + 0.5f) * Chunk.SIZE_Z);

            Vector3f cameraPos = CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
            result.x -= cameraPos.x;
            result.z -= cameraPos.z;

            return result.length();
        }
    }

    private Vector3f getPlayerPosition() {
        if (player != null) {
            return player.getPosition();
        }
        return new Vector3f();
    }

    /**
     * Creates the world time events to play the game's soundtrack at specific times.
     */
    public void initTimeEvents() {

        final AudioManager audioManager = CoreRegistry.get(AudioManager.class);

        // SUNRISE
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.1, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:SpacialWinds"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:Heaven"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:Sunrise"));
                }
            }
        });

        // AFTERNOON
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.25, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:DwarfForge"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:SpaceExplorers"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:Afternoon"));
                }
            }
        });

        // SUNSET
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.4, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:OrcFortress"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:PeacefulWorld"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:Sunset"));
                }
            }
        });

        // NIGHT
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.6, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:CreepyCaves"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:ShootingStars"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:Dimlight"));
                }
            }
        });

        // NIGHT
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.75, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:CreepyCaves"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:NightTheme"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:OtherSide"));
                }
            }
        });

        // BEFORE SUNRISE
        worldTimeEventManager.addWorldTimeEvent(new WorldTimeEvent(0.9, true) {
            @Override
            public void run() {
                if (getPlayerPosition().y < 50) {
                    audioManager.playMusic(Assets.getMusic("engine:CreepyCaves"));
                } else if (getPlayerPosition().y > 175) {
                    audioManager.playMusic(Assets.getMusic("engine:Heroes"));
                } else {
                    audioManager.playMusic(Assets.getMusic("engine:Resurface"));
                }
            }
        });
    }

    /**
     * Updates the currently visible chunks (in sight of the player).
     */
    public void updateAndQueueVisibleChunks() {
        statDirtyChunks = 0;
        statVisibleChunks = 0;
        statIgnoredPhases = 0;

        for (int i = 0; i < chunksInProximity.size(); i++) {
            Chunk c = chunksInProximity.get(i);
            ChunkMesh[] mesh = c.getMesh();

            if (config.getRendering().isDynamicShadows()) {
                if (isChunkVisibleLight(c) && isChunkValidForRender(c)) {
                    if (triangleCount(mesh, ChunkMesh.RENDER_PHASE.OPAQUE) > 0)
                        renderQueueChunksOpaqueShadow.add(c);
                    else
                        statIgnoredPhases++;
                }
            }

            if (isChunkVisible(c) && isChunkValidForRender(c)) {

                if (triangleCount(mesh, ChunkMesh.RENDER_PHASE.OPAQUE) > 0)
                    renderQueueChunksOpaque.add(c);
                else
                    statIgnoredPhases++;

                if (triangleCount(mesh, ChunkMesh.RENDER_PHASE.WATER_AND_ICE) > 0)
                    renderQueueChunksSortedWater.add(c);
                else
                    statIgnoredPhases++;

                if (triangleCount(mesh, ChunkMesh.RENDER_PHASE.BILLBOARD_AND_TRANSLUCENT) > 0 && i < MAX_BILLBOARD_CHUNKS)
                    renderQueueChunksSortedBillboards.add(c);
                else
                    statIgnoredPhases++;

                if (i < MAX_ANIMATED_CHUNKS)
                    c.setAnimated(true);
                else
                    c.setAnimated(false);

                if (c.getPendingMesh() != null) {
                    for (int j = 0; j < c.getPendingMesh().length; j++) {
                        c.getPendingMesh()[j].generateVBOs();
                    }
                    if (c.getMesh() != null) {
                        for (int j = 0; j < c.getMesh().length; j++) {
                            c.getMesh()[j].dispose();
                        }
                    }
                    c.setMesh(c.getPendingMesh());
                    c.setPendingMesh(null);
                }

                if ((c.isDirty() || c.getMesh() == null) && isChunkValidForRender(c)) {
                    statDirtyChunks++;
                    chunkUpdateManager.queueChunkUpdate(c, ChunkUpdateManager.UPDATE_TYPE.DEFAULT);
                }

                statVisibleChunks++;
            } else if (i > config.getRendering().getMaxChunkVBOs()) {
                if (mesh != null) {
                    // Make sure not too many chunk VBOs are available in the video memory at the same time
                    // Otherwise VBOs are moved into system memory which is REALLY slow and causes lag
                    for (ChunkMesh m : mesh) {
                        m.dispose();
                    }
                    c.setMesh(null);
                }
            }
        }
    }

    private int triangleCount(ChunkMesh[] mesh, ChunkMesh.RENDER_PHASE type) {
        int count = 0;

        if (mesh != null) {
            for (ChunkMesh aMesh : mesh) {
                count += aMesh.triangleCount(type);
            }
        }

        return count;
    }

    private void resetStats() {
        statChunkMeshEmpty = 0;
        statChunkNotReady = 0;
        statRenderedTriangles = 0;
    }

    /**
     * Renders the world.
     */
    public void render() {
        resetStats();

        updateAndQueueVisibleChunks();

        DefaultRenderingProcess.getInstance().beginRenderReflectedScene();
        glCullFace(GL11.GL_FRONT);
        getActiveCamera().setReflected(true);
        renderWorldReflection(getActiveCamera());
        getActiveCamera().setReflected(false);
        glCullFace(GL11.GL_BACK);
        DefaultRenderingProcess.getInstance().endRenderReflectedScene();

        if (config.getRendering().isDynamicShadows()) {
            DefaultRenderingProcess.getInstance().beginRenderSceneShadowMap();
            //glCullFace(GL11.GL_FRONT);
            renderShadowMap(lightCamera);
            //glCullFace(GL11.GL_BACK);
            DefaultRenderingProcess.getInstance().endRenderSceneShadowMap();
        }

        renderWorld(getActiveCamera());

        /* RENDER THE FINAL POST-PROCESSED SCENE */
        PerformanceMonitor.startActivity("Render Post-Processing");
        DefaultRenderingProcess.getInstance().renderScene();
        PerformanceMonitor.endActivity();

        if (activeCamera != null && !config.getSystem().isDebugFirstPersonElementsHidden()) {
            PerformanceMonitor.startActivity("Render First Person");

            glClear(GL_DEPTH_BUFFER_BIT);
            glPushMatrix();
            glLoadIdentity();

            activeCamera.updateMatrices(90f);
            activeCamera.loadProjectionMatrix();

            for (RenderSystem renderer : _systemManager.iterateRenderSubscribers()) {
                renderer.renderFirstPerson();
            }

            activeCamera.updateMatrices();

            glPopMatrix();

            PerformanceMonitor.endActivity();
        }
    }

    public void renderWorld(Camera camera) {
        if (config.getSystem().isDebugRenderWireframe())
            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

        DefaultRenderingProcess.getInstance().beginRenderSceneOpaque(true);
        /* SKYSPHERE */
        PerformanceMonitor.startActivity("Render Sky");
        camera.lookThroughNormalized();
        skysphere.render();
        PerformanceMonitor.endActivity();

        /* WORLD RENDERING */
        PerformanceMonitor.startActivity("Render World");
        camera.lookThrough();

        boolean headUnderWater = isUnderWater();

        PerformanceMonitor.startActivity("Render Objects (Opaque)");

        for (RenderSystem renderer : _systemManager.iterateRenderSubscribers()) {
            renderer.renderOpaque();
        }

        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Render Chunks (Opaque)");

        /*
         * FIRST RENDER PASS: OPAQUE ELEMENTS
         */
        while (renderQueueChunksOpaque.size() > 0)
            renderChunk(renderQueueChunksOpaque.poll(), ChunkMesh.RENDER_PHASE.OPAQUE, camera, CHUNK_RENDER_MODE.DEFAULT);

        PerformanceMonitor.endActivity();

        DefaultRenderingProcess.getInstance().endRenderSceneOpaque();
        DefaultRenderingProcess.getInstance().beginRenderSceneTransparent(true);

        PerformanceMonitor.startActivity("Render Chunks (Transparent)");

        /*
         * SECOND RENDER PASS: BILLBOARDS
         */
        while (renderQueueChunksSortedBillboards.size() > 0)
            renderChunk(renderQueueChunksSortedBillboards.poll(), ChunkMesh.RENDER_PHASE.BILLBOARD_AND_TRANSLUCENT, camera, CHUNK_RENDER_MODE.DEFAULT);

        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Render Chunks (Water, Ice)");

        // Make sure the water surface is rendered if the player is swimming
        if (headUnderWater) {
            glDisable(GL11.GL_CULL_FACE);
        }

        /*
        * THIRD (AND FOURTH) RENDER PASS: WATER AND ICE
        */
        while (renderQueueChunksSortedWater.size() > 0) {
            Chunk c = renderQueueChunksSortedWater.poll();
            renderChunk(c, ChunkMesh.RENDER_PHASE.WATER_AND_ICE, camera, CHUNK_RENDER_MODE.DEFAULT);
        }

        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Render Objects (Transparent)");

        for (RenderSystem renderer : _systemManager.iterateRenderSubscribers()) {
            renderer.renderTransparent();
        }

        PerformanceMonitor.endActivity();

        DefaultRenderingProcess.getInstance().endRenderSceneTransparent();
        DefaultRenderingProcess.getInstance().beginRenderSceneOpaque(false);

        PerformanceMonitor.startActivity("Render Overlays");

        for (RenderSystem renderer : _systemManager.iterateRenderSubscribers()) {
            renderer.renderOverlay();
        }

        PerformanceMonitor.endActivity();

        if (headUnderWater)
            glEnable(GL11.GL_CULL_FACE);

        DefaultRenderingProcess.getInstance().endRenderSceneOpaque();

        if (config.getSystem().isDebugRenderWireframe())
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }

    public void renderWorldReflection(Camera camera) {
        PerformanceMonitor.startActivity("Render World (Reflection)");
        camera.lookThroughNormalized();
        skysphere.render();

        if (config.getRendering().isReflectiveWater()) {
            camera.lookThrough();

            for (Chunk c : renderQueueChunksOpaque)
                renderChunk(c, ChunkMesh.RENDER_PHASE.OPAQUE, camera, CHUNK_RENDER_MODE.REFLECTED);
        }

        PerformanceMonitor.endActivity();
    }

    public void renderShadowMap(Camera camera) {
        PerformanceMonitor.startActivity("Render World (Shadow Map)");

        camera.lookThrough();

        while (renderQueueChunksOpaqueShadow.size() > 0)
            renderChunk(renderQueueChunksOpaqueShadow.poll(), ChunkMesh.RENDER_PHASE.OPAQUE, camera, CHUNK_RENDER_MODE.SHADOW_MAP);

        for (RenderSystem renderer : _systemManager.iterateRenderSubscribers()) {
            renderer.renderShadows();
        }

        PerformanceMonitor.endActivity();
    }

    private void renderChunk(Chunk chunk, ChunkMesh.RENDER_PHASE phase, Camera camera,CHUNK_RENDER_MODE mode) {

        if (chunk.getChunkState() == ChunkState.COMPLETE && chunk.getMesh() != null) {

            ShaderProgram shader = null;

            Vector3f cameraPosition = camera.getPosition();
            Vector3d chunkPositionRelToCamera =
                    new Vector3d(chunk.getPos().x * Chunk.SIZE_X - cameraPosition.x, chunk.getPos().y * Chunk.SIZE_Y - cameraPosition.y, chunk.getPos().z * Chunk.SIZE_Z - cameraPosition.z);

            if (mode == CHUNK_RENDER_MODE.DEFAULT || mode == CHUNK_RENDER_MODE.REFLECTED) {
                shader = ShaderManager.getInstance().getShaderProgram("chunk");
                shader.enable();

                if (phase == ChunkMesh.RENDER_PHASE.WATER_AND_ICE) {
                    // This chunks can actually contain water...
                    shader.setActiveFeatures(ShaderProgram.ShaderProgramFeatures.FEATURE_TRANSPARENT_PASS.getValue());
                } else if (phase == ChunkMesh.RENDER_PHASE.BILLBOARD_AND_TRANSLUCENT) {
                    shader.setActiveFeatures(ShaderProgram.ShaderProgramFeatures.FEATURE_ALPHA_REJECT.getValue());
                } else {
                    shader.setActiveFeatures(0);
                }

                if (config.getRendering().isDynamicShadows()) {
                    if (lightCamera != null) {
                        Vector3d chunkPositionRelToLightCamera =
                                new Vector3d(chunk.getPos().x * Chunk.SIZE_X - lightCamera.getPosition().x, chunk.getPos().y * Chunk.SIZE_Y - lightCamera.getPosition().y, chunk.getPos().z * Chunk.SIZE_Z - lightCamera.getPosition().z);
                        shader.setFloat3("chunkPositionRelToLightCamera", (float) chunkPositionRelToLightCamera.x, (float) chunkPositionRelToLightCamera.y, (float)  chunkPositionRelToLightCamera.z);
                    }
                }

                shader.setFloat3("chunkPositionWorld", (float) (chunk.getPos().x * Chunk.SIZE_X), (float) (chunk.getPos().y * Chunk.SIZE_Y), (float) (chunk.getPos().z * Chunk.SIZE_Z));
                shader.setFloat("animated", chunk.getAnimated() ? 1.0f : 0.0f);

                if (mode == CHUNK_RENDER_MODE.REFLECTED) {
                    shader.setFloat("clip", camera.getClipHeight());
                } else {
                    shader.setFloat("clip", 0.0f);
                }
            } else if (mode == CHUNK_RENDER_MODE.SHADOW_MAP) {
                shader = ShaderManager.getInstance().getShaderProgram("shadowMap");
                shader.enable();
            }

            if (shader == null)
                return;

            GL11.glPushMatrix();

            GL11.glTranslated(chunkPositionRelToCamera.x, chunkPositionRelToCamera.y, chunkPositionRelToCamera.z);

            for (int i = 0; i < VERTICAL_SEGMENTS; i++) {
                if (!chunk.getMesh()[i].isEmpty()) {
                    if (config.getSystem().isDebugRenderChunkBoundingBoxes()) {
                        AABBRenderer aabbRenderer = new AABBRenderer(chunk.getSubMeshAABB(i));
                        aabbRenderer.renderLocally(1f);
                        statRenderedTriangles += 12;
                    }

                    shader.enable();
                    chunk.getMesh()[i].render(phase);
                    statRenderedTriangles += chunk.getMesh()[i].triangleCount();
                }
            }

            GL11.glPopMatrix();
        } else {
            statChunkNotReady++;
        }
    }

    public float getRenderingLightValue() {
        return getRenderingLightValueAt(new Vector3f(getActiveCamera().getPosition()));
    }

    public float getRenderingLightValueAt(Vector3f pos) {
        float lightValueSun = (float) Math.pow(0.76, 16 - worldProvider.getSunlight(pos));
        lightValueSun *= getDaylight();
        float lightValueBlock = (float) Math.pow(0.76, 16 - worldProvider.getLight(pos));

        return (lightValueSun + lightValueBlock * (1.0f - lightValueSun)) + (1.0f - (float) getDaylight()) * 0.05f;
    }

    public void update(float delta) {
        PerformanceMonitor.startActivity("Update Tick");
        updateTick(delta);
        PerformanceMonitor.endActivity();

        // Free unused space
        PerformanceMonitor.startActivity("Update Chunk Cache");
        chunkProvider.update();
        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Update Close Chunks");
        updateChunksInProximity(false);
        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Skysphere");
        skysphere.update(delta);
        PerformanceMonitor.endActivity();

        if (activeCamera != null) {
            activeCamera.update(delta);
        }

        if (lightCamera != null) {
            positionLightCamera();
            lightCamera.update(delta);
        }

        // And finally fire any active events
        PerformanceMonitor.startActivity("Fire Events");
        worldTimeEventManager.fireWorldTimeEvents();
        PerformanceMonitor.endActivity();

        PerformanceMonitor.startActivity("Physics Renderer");
        bulletPhysics.update(delta);
        PerformanceMonitor.endActivity();
    }

    public void positionLightCamera() {
        int lightPosX = calcCamChunkOffsetX() * Chunk.CHUNK_SIZE.x;
        int lightPosZ = calcCamChunkOffsetZ() * Chunk.CHUNK_SIZE.z;

        // Shadows are rendered around the player so...
        Vector3f lightPosition = new Vector3f(lightPosX, 0.0f, lightPosZ);

        // ... we position our new camera at the position of the player and move it
        // quite a bit into the direction of the sun (our main light).

        // Make sure the sun does not move too often since it causes massive shadow flickering (from hell to the max)!
        float stepSize = 10.0f;
        Vector3f sunDirection = skysphere.getQuantizedSunDirection(stepSize);

        Vector3f sunPosition = new Vector3f(sunDirection);
        sunPosition.scale(500f);

        lightPosition.add(sunPosition);
        lightCamera.getPosition().set(lightPosition);

        // and adjust it to look from the sun direction into the direction of our player
        Vector3f negSunDirection = new Vector3f(sunDirection);
        negSunDirection.scale(-1.0f);

        lightCamera.getViewingDirection().set(negSunDirection);
    }

    public boolean isUnderWater() {
        Vector3f cameraPos = CoreRegistry.get(WorldRenderer.class).getActiveCamera().getPosition();
        Block block = CoreRegistry.get(WorldProvider.class).getBlock(new Vector3f(cameraPos));
        return block.isLiquid();
    }

    /**
     * Updates the tick variable that animation is based on
     */
    private void updateTick(float delta) {
        tick += delta * 1000;
    }

    /**
     * Returns the maximum height at a given position.
     *
     * @param x The X-coordinate
     * @param z The Z-coordinate
     * @return The maximum height
     */
    public final int maxHeightAt(int x, int z) {
        for (int y = Chunk.SIZE_Y - 1; y >= 0; y--) {
            if (worldProvider.getBlock(x, y, z).getId() != 0x0)
                return y;
        }

        return 0;
    }

    /**
     * Chunk position of the player.
     *
     * @return The player offset on the x-axis
     */
    private int calcCamChunkOffsetX() {
        return (int) (getActiveCamera().getPosition().x / Chunk.SIZE_X);
    }

    /**
     * Chunk position of the player.
     *
     * @return The player offset on the z-axis
     */
    private int calcCamChunkOffsetZ() {
        return (int) (getActiveCamera().getPosition().z / Chunk.SIZE_Z);
    }

    /**
     * Sets a new player and spawns him at the spawning point.
     *
     * @param p The player
     */
    public void setPlayer(LocalPlayer p) {
        player = p;
        chunkProvider.addRegionEntity(p.getEntity(), config.getRendering().getActiveViewingDistance());
        updateChunksInProximity(true);
    }

    public void changeViewDistance(int viewingDistance) {
        logger.debug("New Viewing Distance: {}", viewingDistance);
        if (player != null) {
            chunkProvider.addRegionEntity(player.getEntity(), viewingDistance);
        }
        updateChunksInProximity(true);
    }

    public ChunkProvider getChunkProvider() {
        return chunkProvider;
    }

    /**
     * Disposes this world.
     */
    public void dispose() {
        worldProvider.dispose();
        WorldInfo worldInfo = worldProvider.getWorldInfo();
        try {
            WorldInfo.save(new File(PathManager.getInstance().getWorldSavePath(worldInfo.getTitle()), WorldInfo.DEFAULT_FILE_NAME), worldInfo);
        } catch (IOException e) {
            logger.error("Failed to save world manifest", e);
        }

        CoreRegistry.get(AudioManager.class).stopAllSounds();

        chunkStore.dispose();
        // TODO: this should be elsewhere, perhaps within the chunk cache.
        File chunkFile = new File(PathManager.getInstance().getWorldSavePath(worldProvider.getTitle()), worldProvider.getTitle() + ".dat");
        try {
            FileOutputStream fileOut = new FileOutputStream(chunkFile);
            BufferedOutputStream bos = new BufferedOutputStream(fileOut);
            ObjectOutputStream out = new ObjectOutputStream(bos);
            out.writeObject(chunkStore);
            out.close();
            bos.flush();
            bos.close();
            fileOut.close();
        } catch (IOException e) {
            logger.error("Error saving chunks", e);
        }
    }

    /**
     * @return true if pregeneration is complete
     */
    public boolean pregenerateChunks() {
        boolean complete = true;
        int newChunkPosX = calcCamChunkOffsetX();
        int newChunkPosZ = calcCamChunkOffsetZ();
        int viewingDistance = config.getRendering().getActiveViewingDistance();

        chunkProvider.update();
        for (Vector3i pos : Region3i.createFromCenterExtents(new Vector3i(newChunkPosX, 0, newChunkPosZ), new Vector3i(viewingDistance / 2, 0, viewingDistance / 2))) {
            Chunk chunk = chunkProvider.getChunk(pos);
            if (chunk == null || chunk.getChunkState() != ChunkState.COMPLETE) {
                complete = false;
            } else if (chunk.isDirty()) {
                WorldView view = worldProvider.getLocalView(chunk.getPos());
                if (view == null) {
                    continue;
                }
                chunk.setDirty(false);

                ChunkMesh[] newMeshes = new ChunkMesh[VERTICAL_SEGMENTS];
                for (int seg = 0; seg < VERTICAL_SEGMENTS; seg++) {
                    newMeshes[seg] = chunkTessellator.generateMesh(view, chunk.getPos(), Chunk.SIZE_Y / VERTICAL_SEGMENTS, seg * (Chunk.SIZE_Y / VERTICAL_SEGMENTS));
                }

                chunk.setPendingMesh(newMeshes);

                if (chunk.getPendingMesh() != null) {

                    for (int j = 0; j < chunk.getPendingMesh().length; j++) {
                        chunk.getPendingMesh()[j].generateVBOs();
                    }
                    if (chunk.getMesh() != null) {
                        for (int j = 0; j < chunk.getMesh().length; j++) {
                            chunk.getMesh()[j].dispose();
                        }
                    }
                    chunk.setMesh(chunk.getPendingMesh());
                    chunk.setPendingMesh(null);
                }
                return false;
            }
        }
        return complete;
    }

    public void printScreen() {
        GL11.glReadBuffer(GL11.GL_FRONT);
        final int width = Display.getWidth();
        final int height = Display.getHeight();
        //int bpp = Display.getDisplayMode().getBitsPerPixel(); does return 0 - why?
        final int bpp = 4;
        final ByteBuffer buffer = BufferUtils.createByteBuffer(width * height * bpp); // hardcoded until i know how to get bpp
        GL11.glReadPixels(0, 0, width, height, (bpp == 3) ? GL11.GL_RGB : GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);
        Runnable r = new Runnable() {
            @Override
            public void run() {
                Calendar cal = Calendar.getInstance();
                SimpleDateFormat sdf = new SimpleDateFormat("yyMMddHHmmssSSS");

                File file = new File(PathManager.getInstance().getScreensPath(), sdf.format(cal.getTime()) + ".png");
                BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

                for (int x = 0; x < width; x++)
                    for (int y = 0; y < height; y++) {
                        int i = (x + width * y) * bpp;
                        int r = buffer.get(i) & 0xFF;
                        int g = buffer.get(i + 1) & 0xFF;
                        int b = buffer.get(i + 2) & 0xFF;
                        image.setRGB(x, height - (y + 1), (0xFF << 24) | (r << 16) | (g << 8) | b);
                    }

                try {
                    ImageIO.write(image, "png", file);
                } catch (IOException e) {
                    logger.warn("Could not save screenshot!", e);
                }
            }
        };

        CoreRegistry.get(GameEngine.class).submitTask("Write screenshot", r);
    }


    @Override
    public String toString() {
        return String.format("world (numdropped: %d, biome: %s, time: %.2f, exposure: %.2f, sun: %.2f, cache: %fMb, dirty: %d, ign: %d, vis: %d, tri: %d, empty: %d, !ready: %d, seed: \"%s\", title: \"%s\")", ((MeshRenderer) CoreRegistry.get(ComponentSystemManager.class).get("engine:MeshRenderer")).lastRendered, getPlayerBiome(), worldProvider.getTimeInDays(), DefaultRenderingProcess.getInstance().getExposure(), skysphere.getSunPosAngle(), chunkProvider.size(), statDirtyChunks, statIgnoredPhases, statVisibleChunks, statRenderedTriangles, statChunkMeshEmpty, statChunkNotReady, worldProvider.getSeed(), worldProvider.getTitle());
    }

    public LocalPlayer getPlayer() {
        return player;
    }

    public boolean isAABBVisible(Camera cam, AABB aabb) {
        return cam.getViewFrustum().intersects(aabb);
    }

    public boolean isAABBVisibleLight(AABB aabb) {
        return isAABBVisible(lightCamera, aabb);
    }

    public boolean isAABBVisible(AABB aabb) {
        return isAABBVisible(activeCamera, aabb);
    }

    public boolean isChunkValidForRender(Chunk c) {
        return worldProvider.getLocalView(c.getPos()) != null;
    }

    public boolean isChunkVisible(Camera cam, Chunk c) {
        return cam.getViewFrustum().intersects(c.getAABB());
    }

    public boolean isChunkVisibleLight(Chunk c) {
        return isChunkVisible(lightCamera, c);
    }

    public boolean isChunkVisible(Chunk c) {
        return isChunkVisible(activeCamera, c);
    }

    public double getDaylight() {
        return skysphere.getDaylight();
    }

    public WorldBiomeProvider.Biome getPlayerBiome() {
        Vector3f pos = getPlayerPosition();
        return worldProvider.getBiomeProvider().getBiomeAt(pos.x, pos.z);
    }

    public WorldProvider getWorldProvider() {
        return worldProvider;
    }

    public BlockGrid getBlockGrid() {
        return blockGrid;
    }

    public Skysphere getSkysphere() {
        return skysphere;
    }

    public double getTick() {
        return tick;
    }

    public List<Chunk> getChunksInProximity() {
        return chunksInProximity;
    }

    public BulletPhysics getBulletRenderer() {
        return bulletPhysics;
    }

    public Camera getActiveCamera() {
        return activeCamera;
    }

    public Camera getLightCamera() {
        return lightCamera;
    }

    public ChunkTessellator getChunkTesselator() {
        return chunkTessellator;
    }
}
